## JS
* 闭包是什么？闭包的优缺点

  >指有权访问另一个函数作用域中的变量的函数。

  优点： 
    * 可以读取函数内部变量
    * 在被调用后仍旧占用内存，不会被GC回收，实现共享局部变量

  缺点： 
    * 常驻内存会增大内存的使用量，使用不当会造成内存泄漏（因为IE9以前使用的垃圾收集方法是引用计数法,现在大部分都是标记清除）--解决方法：在退出内存的时候清除不使用的局部变量
    * 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

* this的指向问题？[参考](https://juejin.im/post/59bfe84351882531b730bac2#heading-8)

    * ES5中 指向最后调用它的对象（匿名函数this指向window全局对象）
    * 改变this的几种：
        
        * 使用箭头函数
        * 内部_this=this
        * call、apply、bind
            > apply和call类似，传入参数不同，bind创建新的函数，必须手动调用（ a.bind(this,1,2)() ）
        * new实例化一个对象 
    * 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined

* js中的基本类型? (没有object!)

  string、number、boolean、null、undefined、symbol(es6)

* typeof 判断类型的注意点。(typeof 对于基本类型，除了 null 会显示obejct 都可以显示正确的类型, typeof 对于对象、数组都是object)

* 箭头函数和普通函数的区别？

  * 箭头函数是匿名函数，没有构造函数，不能使用new
  * 箭头函数没有原型属性
  * 箭头函数会捕获其所在上下文的this，作为自己的this
  * apply和call只会传入参数，而不会改变this
  * 箭头函数不绑定arguments，可以使用rest参数...
  * 箭头函数不能作为generator函数，不能使用yield
  * 普通函数的this指向最后调用他的对象
  
* 垂直居中如何实现除flex外 [参考](https://juejin.im/post/5b9a4477f265da0ad82bf921)

    仅居中元素定宽高：

    * absolute定位top、left各50% + 负margin
    * absolute定位top、right、bottom、left各0 + margin auto
    * absolute定位top、left使用calc

    居中元素不定宽高：

    * absolute定位top、left各50% + transform:translate(-50%,-50%)
    * 行内元素line-height居中，父元素line-height等于height+text-align：center
    * writing-mode居中
    * table
    * display:grid 

* 原型链的继承原理 [参考](https://juejin.im/post/5bebc6a3e51d4575125a39ca)

    ![图片](https://user-gold-cdn.xitu.io/2018/11/14/167114a25a670ace?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    >一个对象 A的__proto__属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链

* 事件模型
    * 捕获阶段：当点击一个元素触发事件时. 事件会先从元素的最外层父元素一层一层进入到触发的元素
    * 目标阶段：事件响应到触发事件元素上的时间
    * 冒泡阶段：事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；

* 事件委托

    假设有一个列表，如果给每个列表项加上函数，会消耗很多内存。可以把点击事件绑定到父元素，点击的时候再去匹配判断目标元素,从而节省内存，提高效率。

    * e.target.id='item1'
    * e.target.matches('div.item')

* 浏览器中cookie，localStorage，sessionStorage，indexDB的应用场景 [参考](https://juejin.im/post/5b18fd93f265da6e1b5548e0)

    cookie：存储在浏览器中的纯文本。每次请求浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中，大小和数量有限制，作为一种标识，用来记录用户的行为，而并非用户的身份信息。

    localStorage：存储到本地，永久存储。同一浏览器跨窗口共享。本地购物车。

    sessionStorage：存储到浏览器，窗口或标签页关闭就不存在。同一浏览器并且同一个标签页才能共享。保存敏感重要信息。

    indexDB：大量结构化数据，节省服务器开支。


* js的垃圾回收机制 [参考](https://juejin.im/post/5a6b3fcaf265da3e2c385375)

  v8引擎使用标记清除 

* 说一下浏览器缓存机制吧

    1. 看是不是强缓存，如果命中了，就直接使用缓存了；
    2. 如果不是强缓存，发送请求到服务器验证是否命中协商缓存；
    3. 如果命中协商缓存，服务器返回304告诉浏览器使用本地缓存；
    4. 不然就返回新资源。

    * 强缓存http请求头部参数Expires中绝对时间 和 Cahe-Control:max-age中相对时间，一旦命中 chrome中会显示200 OK (from disk cache) 或者 200 OK (from memory cache)

    * 协商缓存
    
        * 根据上次响应中的ETag_value（唯一资源验证号）, 自动往请求header中添加If-None-Match字段. 服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较, 若相同, 则命中协商缓存, 返回304响应.

        * 根据上次响应中的Last-Modified_value（资源最后修改时间）, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.

        * ETag优先级比Last-Modified高, 同时存在时, 前者覆盖后者.

    ## 三级缓存原理 (访问缓存优先级)
    1. 先在内存（memory cache）中查找,如果有,直接加载。
    2. 如果内存中不存在,则在磁盘（disk cache）中查找,如果有直接加载。
    3. 如果磁盘中也没有,那么就进行网络请求。
    3. 请求获取的资源缓存到磁盘和内存。

* new一个对象的时候发生了什么？

        var a = new myFunction("Li","Cherry");

        new myFunction{
            var obj = {};
            obj.__proto__ = myFunction.prototype;
            var result = myFunction.call(obj,"Li","Cherry");
            return typeof result === 'object'? result : obj;
        }

    * 构造一个全新的对象
    * 将这个对象执行__proto__链接（对象的__proto__指向构造函数的prototype）
    * 使用call绑定this到全新对象
    * 如果函数没有返回其它对象，则返回新对象

    `实例的_proto_指向构造函数的prototype`

* 手写一个promise 或者讲述其原理 [参考](https://juejin.im/post/5aa7868b6fb9a028dd4de672)



* promise中的resolve是什么类型，promise有几种状态？

    Promise.resolve(42) 相当于new Promise(function(resolve){resolve(42)})，进入fulfilled状态

    Promise.resolve().then(task1).then(task2).catch(onRejected) , 如果task1抛出异常throw Error(),并不会进行task2，会直接进入catch执行onReject

    promise有三种状态：
        
    * pending       promise对象初始状态为pending
    * fulfilled     当调用resolve（成功）时，从pending=>fulfilled
    * rejected      当调用rejected（失败）时，从pending=>rejected
    > 注意promsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变

* 长连接是如何实现的



* 简单说一下什么是盒子模型，以及css中box-sizing：border-box 有什么用

    从里到外：content padding border margin

    W3C盒模型:content-box

    IE盒模型:border-box

    width包含了border、padding和content

* vue中父子组件通信的方式，越多越好 [参考](https://juejin.im/post/5bd18c72e51d455e3f6e4334)

    * prop,父组件传给子组件
    * 子组件this.$emit('btnClick'（String）,参数)，父组件@btnClick="handleClick"
    * 

* js中const，var，let的区别

    * let、const生成块级作用域（块作用域之外无法访问），不允许重复声名；
    * let、const不会变量提升（不允许先调用后声明）；
    * let、const存在暂时性死区；
    * const声明后不能更改，不能先声明后赋值；

* 假设我设置一个定时器setTimeout 1000ms后启动, 1000ms后一定启动吗? 为什么?

    clearTimeOut可以清除定时器，例如防抖函数

* redux是如何工作实现的？

    * 将state统一放在store中管理，通过createStore生成store
    * 组件通过dispatch方法触发action方法，真正操作state的是在reducer中，返回新的state

* Macrotasks（宏任务）和Microtasks（微任务）

    > 都属于异步任务中的一种
    * macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering
    * microtasks: process.nextTick, Promise, MutationObserver

    任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。同步任务执行完执行微任务，等所有微任务执行完后执行宏任务。

        setTimeout(()=>{
        console.log('A');
        },0);
        var obj={
            func:function () {
                setTimeout(function () {
                    console.log('B')
                },0);
                return new Promise(function (resolve) {
                    console.log('C');
                    resolve();
                })
            }
        };
        obj.func().then(function () {
            console.log('D')
        });
        console.log('E');

    > 依次输出 C E D A B ,promise中的操作立即执行，then方法指定的回调函数在所有同步脚本执行完毕后才会执行

    * generator [参考](http://es6.ruanyifeng.com/#docs/generator)

## CSS

## React

* react 中props 与 state的区别

    * props由父组件传入，而state是组件自身的
    * props可以用defaultProps设置默认值，propTypes设置参数类型
    * props中的数据只读不可修改，如果父组件得state传入子组件，想要修改state需要传入方法
    * state不能直接改变，需要this.setState()来改变

* react 中function组件与class组件的异同点

    * function组件没有生命周期方法，没有state，展示型组件
    * function组件没有this
    * function组件中应避免定义函数，每次调用都会重新定义一遍

* react native编译过程，有哪些被编译成原生，那些依旧是js?

* React中的controlled component 和 uncontrolled component区别（受控组件和不受控组件）

    [受控组件](https://react.docschina.org/docs/forms.html#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6)

    [非受控组件](https://react.docschina.org/docs/uncontrolled-components.html)

* react-router内部实现机制

    [react-router的实现原理](https://blog.csdn.net/tangzhl/article/details/79696055)
