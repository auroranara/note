## JS
* 闭包是什么？闭包的优缺点

  >指有权访问另一个函数作用域中的变量的函数。

  优点： 
    * 可以读取函数内部变量
    * 在被调用后仍旧占用内存，不会被GC回收，实现共享局部变量

  缺点： 
    * 常驻内存会增大内存的使用量，使用不当会造成内存泄漏（因为IE9以前使用的垃圾收集方法是引用计数法,现在大部分都是标记清除）--解决方法：在退出内存的时候清除不使用的局部变量
    * 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

* this的指向问题？[参考](https://juejin.im/post/59bfe84351882531b730bac2#heading-8)

    * ES5中 指向最后调用它的对象（匿名函数this指向window全局对象）
    * 改变this的几种：
        
        * 使用箭头函数
        * 内部_this=this
        * call、apply、bind
            > apply和call类似，传入参数不同，bind创建新的函数，必须手动调用（ a.bind(this,1,2)() ）
        * new实例化一个对象 
    * 箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined

* js中的基本类型? (没有object!)

  string、number、boolean、null、undefined、symbol(es6)

* typeof 判断类型的注意点。(typeof 对于基本类型，除了 null 会显示obejct 都可以显示正确的类型, typeof 对于对象、数组都是object)

* 箭头函数和普通函数的区别？

  * 箭头函数是匿名函数，没有构造函数，不能使用new
  * 箭头函数没有原型属性
  * 箭头函数会捕获其所在上下文的this，作为自己的this
  * apply和call只会传入参数，而不会改变this
  * 箭头函数不绑定arguments，可以使用rest参数...
  * 箭头函数不能作为generator函数，不能使用yield
  * 普通函数的this指向最后调用他的对象
  
* 垂直居中如何实现除flex外 [参考](https://juejin.im/post/5b9a4477f265da0ad82bf921)

    仅居中元素定宽高：

    * absolute定位top、left各50% + 负margin
    * absolute定位top、right、bottom、left各0 + margin auto
    * absolute定位top、left使用calc

    居中元素不定宽高：

    * absolute定位top、left各50% + transform:translate(-50%,-50%)
    * 行内元素line-height居中，父元素line-height等于height+text-align：center
    * writing-mode居中
    * table
    * display:grid 

* 原型链的继承原理 [参考](https://juejin.im/post/5bebc6a3e51d4575125a39ca)

    ![图片](https://user-gold-cdn.xitu.io/2018/11/14/167114a25a670ace?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    >一个对象 A的__proto__属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链

* 可以讲一下什么是事件冒泡吗

    >当点击一个元素触发事件时. 事件会先从元素的最外层父元素一层一层进入到触发的元素, 然后在从触发元素一层一层返回到最外层父元素, 从最外层一层一层进入的阶段叫事件捕获阶段, 从最里层一层一层往外的阶段叫事件冒泡,

* 浏览器中cookie，localStorage，sessionStorage，indexDB的应用场景 [参考](https://juejin.im/post/5b18fd93f265da6e1b5548e0)

    cookie：存储在浏览器中的纯文本。每次请求浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中，大小和数量有限制，作为一种标识，用来记录用户的行为，而并非用户的身份信息。

    localStorage：存储到本地，永久存储。同一浏览器跨窗口共享。本地购物车。

    sessionStorage：存储到浏览器，窗口或标签页关闭就不存在。同一浏览器并且同一个标签页才能共享。保存敏感重要信息。

    indexDB：大量结构化数据，节省服务器开支。


* js的垃圾回收机制 [参考](https://juejin.im/post/5a6b3fcaf265da3e2c385375)

  v8引擎使用标记清除 

* 说一下浏览器缓存机制吧

    1. 看是不是强缓存，如果命中了，就直接使用缓存了；
    2. 如果不是强缓存，发送请求到服务器验证是否命中协商缓存；
    3. 如果命中协商缓存，服务器返回304告诉浏览器使用本地缓存；
    4. 不然就返回新资源。

    * 强缓存http请求头部参数Expires中绝对时间 和 Cahe-Control:max-age中相对时间，一旦命中 chrome中会显示200 OK (from disk cache) 或者 200 OK (from memory cache)

    * 协商缓存
    
        * 根据上次响应中的ETag_value（唯一资源验证号）, 自动往请求header中添加If-None-Match字段. 服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较, 若相同, 则命中协商缓存, 返回304响应.

        * 根据上次响应中的Last-Modified_value（资源最后修改时间）, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.

        * ETag优先级比Last-Modified高, 同时存在时, 前者覆盖后者.

    ## 三级缓存原理 (访问缓存优先级)
    1. 先在内存（memory cache）中查找,如果有,直接加载。
    2. 如果内存中不存在,则在磁盘（disk cache）中查找,如果有直接加载。
    3. 如果磁盘中也没有,那么就进行网络请求。
    3. 请求获取的资源缓存到磁盘和内存。

* new一个对象的时候发生了什么？

        var a = new myFunction("Li","Cherry");

        new myFunction{
            var obj = {};
            obj.__proto__ = myFunction.prototype;
            var result = myFunction.call(obj,"Li","Cherry");
            return typeof result === 'object'? result : obj;
        }

    * 构造一个全新的对象
    * 将这个对象执行__proto__链接（对象的__proto__指向构造函数的prototype）
    * 使用call绑定this到全新对象
    * 如果函数没有返回其它对象，则返回新对象

* 手写一个promise 或者讲述其原理 [参考](https://juejin.im/post/5aa7868b6fb9a028dd4de672)



* promise中的resolve是什么类型，promise有几种状态？

    Promise.resolve(42) 相当于new Promise(function(resolve){resolve(42)})，进入fulfilled状态

    Promise.resolve().then(task1).then(task2).catch(onRejected) , 如果task1抛出异常throw Error(),并不会进行task2，会直接进入catch执行onReject

    promise有三种状态：
        
    * pending       promise对象初始状态为pending
    * fulfilled     当调用resolve（成功）时，从pending=>fulfilled
    * rejected      当调用rejected（失败）时，从pending=>rejected
    > 注意promsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变

* 长连接是如何实现的



* 简单说一下什么是盒子模型，以及css中box-sizing：border-box 有什么用

    从里到外：content padding border margin

    W3C盒模型:content-box

    IE盒模型:border-box

    width包含了border、padding和content

* vue中父子组件通信的方式，越多越好 [参考](https://juejin.im/post/5bd18c72e51d455e3f6e4334)

    * prop,父组件传给子组件
    * 子组件this.$emit('btnClick'（String）,参数)，父组件@btnClick="handleClick"
    * 

* js中const，var，let的区别

    * let、const生成块级作用域（块作用域之外无法访问），不允许重复声名；
    * let、const不会变量提升（不允许先调用后声明）；
    * let、const存在暂时性死区；
    * const声明后不能更改，不能先声明后赋值；

* 假设我设置一个定时器setTimeout 1000ms后启动, 1000ms后一定启动吗? 为什么?

    clearTimeOut可以清除定时器，例如防抖函数

* redux是如何工作实现的？

## CSS

## React

* react 中props 与 state的区别

    * props由父组件传入，而state是组件自身的
    * props可以用defaultProps设置默认值，propTypes设置参数类型
    * props中的数据只读不可修改，如果父组件得state传入子组件，想要修改state需要传入方法
    * state不能直接改变，需要this.setState()来改变

* react 中function组件与class组件的异同点

    * function组件没有生命周期方法，没有state，展示型组件
    * function组件没有this
    * function组件中应避免定义函数，每次调用都会重新定义一遍

* react native编译过程，有哪些被编译成原生，那些依旧是js?